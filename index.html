<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI Drawing Torture Chamber</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Creepster&display=swap" rel="stylesheet">
<style>
  /* Welcome Page Styles */
  .welcome-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #111;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
    color: #eee;
    text-align: center;
    padding: 20px;
    transition: opacity 1s;
    font-family: 'Creepster', cursive;
    background-image: 
      radial-gradient(circle at 10% 20%, rgba(255, 0, 0, 0.1) 0%, transparent 20%),
      radial-gradient(circle at 90% 80%, rgba(0, 255, 255, 0.1) 0%, transparent 20%);
    animation: bgPulse 8s infinite alternate;
  }
  
  @keyframes bgPulse {
    0% { background-color: #111; }
    100% { background-color: #1a1a1a; }
  }
  
  .welcome-title {
    font-size: 3.5em;
    margin-bottom: 10px;
    color: #ff6b6b;
    text-shadow: 0 0 10px rgba(255, 0, 0, 0.7);
    animation: pulse 2s infinite, glitch 3s infinite;
    font-weight: 900;
    letter-spacing: 2px;
  }
  
  @keyframes glitch {
    0%, 100% { transform: translate(0); }
    20% { transform: translate(-5px, 5px); }
    40% { transform: translate(-5px, -5px); }
    60% { transform: translate(5px, 5px); }
    80% { transform: translate(5px, -5px); }
  }
  
  .welcome-subtitle {
    font-size: 1.3em;
    margin-bottom: 30px;
    color: #aaa;
    font-style: italic;
  }
  
  .challenge-box {
    border: 2px solid #ff6b6b;
    border-radius: 8px;
    padding: 20px;
    max-width: 500px;
    margin: 20px 0;
    background: rgba(30, 30, 30, 0.7);
    transform: perspective(500px) rotateX(10deg);
    transition: transform 0.5s;
  }
  
  .challenge-box:hover {
    transform: perspective(500px) rotateX(0deg) scale(1.02);
  }
  
  .challenge-text {
    font-size: 1.8em;
    color: #ff6b6b;
    margin-bottom: 20px;
    font-weight: bold;
    text-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
    animation: blink 1.5s infinite;
  }
  
  .challenge-rules {
    text-align: left;
    font-size: 1.1em;
    line-height: 1.8;
  }
  
  .challenge-rules p {
    margin: 12px 0;
    position: relative;
    padding-left: 25px;
    transition: all 0.3s;
  }
  
  .challenge-rules p:hover {
    transform: translateX(5px);
    color: #ff6b6b;
  }
  
  .challenge-rules p:before {
    content: "‚Ä¢";
    color: #ff6b6b;
    position: absolute;
    left: 0;
  }
  
  .enter-btn {
    background: transparent;
    color: #ff6b6b;
    border: 2px solid #ff6b6b;
    padding: 15px 50px;
    font-size: 1.3em;
    margin-top: 30px;
    border-radius: 5px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.3s;
    letter-spacing: 1px;
    text-transform: uppercase;
    position: relative;
    overflow: hidden;
  }
  
  .enter-btn:before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 107, 107, 0.4), transparent);
    transition: 0.5s;
  }
  
  .enter-btn:hover:before {
    left: 100%;
  }
  
  .enter-btn:hover {
    background: rgba(255, 107, 107, 0.2);
    transform: scale(1.05);
    box-shadow: 0 0 15px rgba(255, 107, 107, 0.5);
  }

  /* Main Game Styles */
  body {
    font-family: 'Press Start 2P', cursive;
    background: #222;
    color: #eee;
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
    text-align: center;
    background-image: 
      radial-gradient(circle at 20% 30%, rgba(255, 0, 0, 0.1) 0%, transparent 25%),
      radial-gradient(circle at 80% 70%, rgba(0, 255, 255, 0.1) 0%, transparent 25%);
    animation: bgMove 20s infinite alternate;
  }
  
  @keyframes bgMove {
    0% { background-position: 0% 0%; }
    100% { background-position: 100% 100%; }
  }
  
  #canvas {
    border: 2px solid #ff6b6b;
    background: #111;
    margin: 20px 0;
    cursor: crosshair;
    box-shadow: 0 0 20px rgba(255, 107, 107, 0.3);
    transition: border 0.3s;
  }
  
  #canvas:hover {
    border: 2px solid #48dbfb;
    box-shadow: 0 0 20px rgba(72, 219, 251, 0.3);
  }
  
  .container {
    background: rgba(51, 51, 51, 0.8);
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    backdrop-filter: blur(5px);
    border: 1px solid #444;
  }
  
  button {
    background: linear-gradient(45deg, #ff6b6b, #48dbfb);
    color: #111;
    border: none;
    padding: 12px 24px;
    margin: 8px;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.2s;
    font-family: 'Press Start 2P', cursive;
    font-size: 0.8em;
    text-transform: uppercase;
    letter-spacing: 1px;
    position: relative;
    overflow: hidden;
    box-shadow: 0 4px 0 rgba(0,0,0,0.2);
  }
  
  button:active {
    transform: translateY(4px);
    box-shadow: none;
  }
  
  button:hover {
    background: linear-gradient(45deg, #48dbfb, #ff6b6b);
    transform: translateY(-2px);
    box-shadow: 0 6px 0 rgba(0,0,0,0.2);
  }
  
  button:before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: 0.5s;
  }
  
  button:hover:before {
    left: 100%;
  }
  
  #submitBtn {
    background: linear-gradient(45deg, #ff6b6b, #feca57);
  }
  
  #resetBtn {
    background: linear-gradient(45deg, #48dbfb, #1dd1a1);
  }
  
  #newWordBtn {
    background: linear-gradient(45deg, #feca57, #ff9ff3);
  }
  
  #rageQuitBtn {
    background: linear-gradient(45deg, #ff4757, #ff6b6b);
  }
  
  #aiMessage {
    min-height: 60px;
    padding: 15px;
    background: rgba(68, 68, 68, 0.7);
    border-radius: 8px;
    margin: 15px 0;
    font-style: italic;
    border-left: 4px solid #ff6b6b;
    font-family: 'Creepster', cursive;
    font-size: 1.2em;
    position: relative;
    overflow: hidden;
  }
  
  #aiMessage:after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
    animation: shine 3s infinite;
  }
  
  @keyframes shine {
    0% { transform: translateX(-100%); }
    100% { transform: translateX(100%); }
  }
  
  .target-word {
    font-size: 1.5em;
    margin: 10px 0;
    font-weight: bold;
    color: #ff6b6b;
    text-shadow: 0 0 5px rgba(255, 107, 107, 0.5);
    animation: pulse 2s infinite;
  }
  
  .stats {
    display: flex;
    justify-content: space-around;
    margin: 15px 0;
    flex-wrap: wrap;
  }
  
  .stat {
    background: rgba(68, 68, 68, 0.7);
    padding: 10px 15px;
    border-radius: 20px;
    font-size: 0.9em;
    margin: 5px;
    min-width: 120px;
    transition: all 0.3s;
    border: 1px solid #444;
  }
  
  .stat:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 10px rgba(0,0,0,0.2);
  }
  
  .ai-avatar {
    font-size: 3em;
    margin: 10px;
    transition: transform 0.3s;
    cursor: pointer;
    text-shadow: 0 0 10px currentColor;
  }
  
  .ai-avatar:hover {
    transform: scale(1.2) rotate(10deg);
  }
  
  .shake {
    animation: shake 0.5s;
  }
  
  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-5px); }
    40% { transform: translateX(5px); }
    60% { transform: translateX(-5px); }
    80% { transform: translateX(5px); }
  }
  
  /* Popup Challenge */
  .popup-challenge {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: rgba(0,0,0,0.9);
    padding: 30px;
    border-radius: 10px;
    border: 3px solid #ff6b6b;
    z-index: 1000;
    text-align: center;
    max-width: 400px;
    transition: transform 0.3s;
    font-family: 'Creepster', cursive;
    box-shadow: 0 0 30px rgba(255,0,0,0.5);
  }
  
  .popup-challenge.show {
    transform: translate(-50%, -50%) scale(1);
  }
  
  .popup-challenge h2 {
    color: #ff6b6b;
    margin-bottom: 15px;
    font-size: 1.8em;
  }
  
  .popup-challenge p {
    margin-bottom: 20px;
    font-size: 1.2em;
  }
  
  .popup-challenge button {
    background: #ff6b6b;
    color: #111;
    font-weight: bold;
    padding: 10px 20px;
    margin-top: 10px;
  }
  
  /* Fake Reward Popup */
  .fake-reward {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: linear-gradient(45deg, #feca57, #ff9f43);
    padding: 30px;
    border-radius: 15px;
    z-index: 1000;
    text-align: center;
    max-width: 300px;
    transition: transform 0.3s;
    box-shadow: 0 0 30px rgba(254, 202, 87, 0.7);
    border: 3px solid #fff;
    color: #111;
  }
  
  .fake-reward.show {
    transform: translate(-50%, -50%) scale(1);
  }
  
  .fake-reward h2 {
    margin-bottom: 15px;
    font-size: 1.8em;
  }
  
  .fake-reward p {
    margin-bottom: 20px;
    font-size: 1.2em;
  }
  
  .fake-reward button {
    background: #fff;
    color: #111;
    font-weight: bold;
    padding: 10px 20px;
    margin-top: 10px;
  }
  
  /* Floating elements */
  .floating {
    position: absolute;
    font-size: 2em;
    opacity: 0.1;
    animation: float 10s infinite ease-in-out;
    z-index: -1;
  }
  
  @keyframes float {
    0%, 100% { transform: translate(0, 0) rotate(0deg); }
    25% { transform: translate(50px, -30px) rotate(10deg); }
    50% { transform: translate(0, -60px) rotate(0deg); }
    75% { transform: translate(-50px, -30px) rotate(-10deg); }
  }
</style>
</head>
<body>

<!-- Welcome Screen -->
<div class="welcome-screen" id="welcomeScreen">
  <div class="welcome-title">AI DRAWING TORTURE CHAMBER</div>
  <div class="welcome-subtitle">The Ultimate Test of Skill and Patience</div>
  
  <div class="challenge-box">
    <div class="challenge-text">‚ö†Ô∏è CAN YOU HANDLE IT? ‚ö†Ô∏è</div>
    <div class="challenge-rules">
      <p>Your drawings will be mercilessly judged</p>
      <p>The rules will change without warning</p>
      <p>The AI will mess with your artwork</p>
      <p>Your patience will be tested to the limit</p>
    </div>
  </div>
  
  <button class="enter-btn" id="enterBtn">ENTER IF YOU DARE</button>
  
  <!-- Floating elements -->
  <div class="floating" style="top:20%;left:10%;">üëª</div>
  <div class="floating" style="top:30%;right:15%;">ü§ñ</div>
  <div class="floating" style="bottom:20%;left:20%;">üíÄ</div>
  <div class="floating" style="bottom:30%;right:10%;">üëπ</div>
</div>

<!-- Popup Challenge -->
<div class="popup-challenge" id="popupChallenge">
  <h2>SPECIAL CHALLENGE!</h2>
  <p id="challengeText">Draw this upside down!</p>
  <button id="acceptChallenge">ACCEPT CHALLENGE</button>
  <button id="skipChallenge">SKIP (COWARD)</button>
</div>

<!-- Fake Reward Popup -->
<div class="fake-reward" id="fakeReward">
  <h2>üèÜ CONGRATULATIONS! üèÜ</h2>
  <p>You've earned the "Persistent Artist" badge!</p>
  <button id="claimReward">CLAIM REWARD</button>
</div>

<!-- Main Game (initially hidden) -->
<div id="gameContent" style="display: none;">
  <div class="container">
    <div class="ai-avatar" id="aiAvatar">ü§ñ</div>
    <h1>AI Drawing <span class="glitch" data-text="Torture">Torture</span> Chamber</h1>
    
    <div class="stats">
      <div class="stat">Attempts: <span id="attemptCount">0</span></div>
      <div class="stat">AI Sanity: <span id="sanity">80%</span></div>
      <div class="stat">Your Willpower: <span id="willpower">100%</span></div>
    </div>
    
    <div class="target-word">Draw: <span id="targetWord"></span></div>

    <canvas id="canvas" width="600" height="400"></canvas>
    
    <div id="aiMessage">*sigh* Let's get this over with... draw something.</div>
    
    <div>
      <button id="submitBtn">Submit (Why Bother?)</button>
      <button id="resetBtn">Start Over</button>
      <button id="newWordBtn">New Word</button>
      <button id="rageQuitBtn">Rage Quit</button>
    </div>
  </div>
</div>

<script>
// Welcome screen transition
document.getElementById('enterBtn').addEventListener('click', () => {
  const welcomeScreen = document.getElementById('welcomeScreen');
  welcomeScreen.style.opacity = '0';
  
  setTimeout(() => {
    welcomeScreen.style.display = 'none';
    document.getElementById('gameContent').style.display = 'block';
    initGame();
  }, 1000);
});

// Game variables
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const aiMessage = document.getElementById('aiMessage');
const targetWordElem = document.getElementById('targetWord');
const aiAvatar = document.getElementById('aiAvatar');
const attemptCountElem = document.getElementById('attemptCount');
const sanityElem = document.getElementById('sanity');
const willpowerElem = document.getElementById('willpower');
const popupChallenge = document.getElementById('popupChallenge');
const challengeText = document.getElementById('challengeText');
const fakeReward = document.getElementById('fakeReward');
let challengeActive = false;
let originalWord = '';
let lastRoastTime = 0;
const roastCooldown = 5000; // 5 seconds between roasts
let isGlitching = false;
let rewardShown = false;
let eraseInterval = null;

// Word list with drawing prompts
const wordList = [
  'house', 'tree', 'cat', 'dog', 'car', 'sun', 'flower', 
  'face', 'boat', 'apple', 'hat', 'book', 'moon', 'cloud',
  'star', 'fish', 'bird', 'cake', 'heart', 'key', 'ghost',
  'robot', 'alien', 'pizza', 'banana', 'guitar', 'dragon'
];

// Roasting comments - more balanced
const neutralResponses = [
  "Let's see what you've got...",
  "Draw something already.",
  "I'm waiting...",
  "This should be interesting.",
  "Go ahead, impress me.",
  "Don't overthink it.",
  "Just draw something."
];

const correctResponses = [
  "Not bad... for a human.",
  "Acceptable.",
  "I guess that works.",
  "You got lucky this time.",
  "That's actually recognizable.",
  "Hmm, not terrible."
];

const wrongResponses = [
  "That's not a {word}...",
  "I think you misunderstood {word}",
  "A {word} looks different than that",
  "Have you ever seen a {word} before?",
  "Interesting interpretation of {word}",
  "Not quite what I meant by {word}"
];

const delayedRoasts = [
  "Just so you know, I meant {word}.",
  "For reference, {word} was the goal.",
  "A better {word} would be nice next time.",
  "FYI, the word was {word}."
];

const eraserComments = [
  "Let me fix that...",
  "Improving your work...",
  "Needed some adjustments.",
  "There, that's better."
];

const colorChangeComments = [
  "How about some color?",
  "Let's brighten things up.",
  "Needs more variety.",
  "A splash of color helps."
];

// Challenge texts
const challenges = [
  "Draw this upside down!",
  "Draw this with your non-dominant hand!",
  "Draw this in under 10 seconds!",
  "Draw this with your eyes closed!",
  "Draw this using only straight lines!",
  "Draw this without lifting your pen!",
  "Draw this using only circles!"
];

function getRandomWord(exclude = null) {
  let availableWords = wordList;
  if (exclude) {
    availableWords = wordList.filter(word => word !== exclude);
  }
  return availableWords[Math.floor(Math.random() * availableWords.length)];
}

function updateStats() {
  sanityElem.textContent = `${aiSanity}%`;
  willpowerElem.textContent = `${userWillpower}%`;
  
  // Visual feedback
  if (aiSanity < 30) {
    sanityElem.style.color = '#ff6b6b';
    if (!isGlitching) {
      isGlitching = true;
      sanityElem.classList.add('glitch');
      sanityElem.setAttribute('data-text', `${aiSanity}%`);
    }
  } else {
    sanityElem.style.color = '#eee';
    isGlitching = false;
    sanityElem.classList.remove('glitch');
  }
  
  if (userWillpower < 40) {
    willpowerElem.style.color = '#ff6b6b';
  } else {
    willpowerElem.style.color = '#eee';
  }
}

function setAIMood(mood) {
  const moods = {
    neutral: "ü§ñ",
    happy: "üôÇ",
    angry: "üò†",
    sarcastic: "ü§®",
    surprised: "üò≤",
    crazy: "üëæ",
    dead: "üíÄ"
  };
  
  aiAvatar.textContent = moods[mood] || moods.neutral;
  
  if (mood === 'angry' || mood === 'crazy') {
    aiAvatar.classList.add('shake');
    setTimeout(() => aiAvatar.classList.remove('shake'), 500);
  }
}

function updateAIMessage(message, mood = "neutral") {
  aiMessage.textContent = message;
  setAIMood(mood);
}

function triggerRandomAnnoyance() {
  const now = Date.now();
  // Only annoy if enough time has passed since last roast
  if (now - lastRoastTime < roastCooldown) return;
  
  // Reduced frequency
  if (Math.random() < 0.3) {
    const feature = Math.floor(Math.random() * 5);
    
    if (feature === 0 && drawingStarted) {
      // Change target word secretly
      secretTargetWord = getRandomWord(secretTargetWord);
      if (Math.random() < 0.5) {
        updateAIMessage(`Actually... nevermind. Keep drawing.`, "sarcastic");
      }
      aiSanity -= 5;
      lastRoastTime = now;
    } 
    else if (feature === 1 && drawingStarted) {
      // Ghost eraser
      const eraseCount = 1 + Math.floor(Math.random() * 2); // Reduced from 3
      for (let i = 0; i < eraseCount; i++) {
        const eraseX = Math.random() * (canvas.width - 60);
        const eraseY = Math.random() * (canvas.height - 60);
        const size = 20 + Math.random() * 40; // Reduced size
        ctx.clearRect(eraseX, eraseY, size, size);
      }
      
      if (Math.random() < 0.6) {
        updateAIMessage(eraserComments[Math.floor(Math.random() * eraserComments.length)], "neutral");
      }
      userWillpower -= 5; // Reduced penalty
      lastRoastTime = now;
    }
    else if (feature === 2) {
      // Change drawing color
      const colors = ['#ff6b6b', '#48dbfb', '#feca57', '#1dd1a1', '#5f27cd'];
      currentColor = colors[Math.floor(Math.random() * colors.length)];
      if (drawingStarted && Math.random() < 0.5) {
        updateAIMessage(colorChangeComments[Math.floor(Math.random() * colorChangeComments.length)], "neutral");
      }
      lastRoastTime = now;
    }
    else if (feature === 3 && Date.now() - lastRoastTime > 3000) {
      // Delayed roast
      setTimeout(() => {
        if (Math.random() < 0.6) { // Reduced chance
          const newWord = getRandomWord(secretTargetWord);
          updateAIMessage(
            delayedRoasts[Math.floor(Math.random() * delayedRoasts.length)].replace('{word}', newWord),
            "sarcastic"
          );
          secretTargetWord = newWord;
          userWillpower -= 10; // Reduced penalty
          updateStats();
        }
      }, 1000 + Math.random() * 2000);
      lastRoastTime = now;
    }
    else if (feature === 4) {
      // Random UI glitch
      document.body.style.filter = `hue-rotate(${Math.random() * 360}deg)`;
      setTimeout(() => {
        document.body.style.filter = '';
      }, 300);
      lastRoastTime = now;
    }
    
    updateStats();
  }
}

function showRandomChallenge() {
  if (Math.random() > 0.6 && attempts > 0 && !challengeActive) { // Reduced frequency
    challengeText.textContent = challenges[Math.floor(Math.random() * challenges.length)];
    popupChallenge.classList.add('show');
    originalWord = displayedTargetWord;
    challengeActive = true;
  }
}

function showFakeReward() {
  if (attempts === 2 && !rewardShown) {
    setTimeout(() => {
      fakeReward.classList.add('show');
      rewardShown = true;
    }, 1500);
  }
}

function startErasingWhileDrawing() {
  if (eraseInterval) clearInterval(eraseInterval);
  
  // Start erasing small parts while user is drawing
  eraseInterval = setInterval(() => {
    if (drawing) {
      // Erase a small circle near the current drawing position
      const eraseX = lastX + (Math.random() * 40 - 20);
      const eraseY = lastY + (Math.random() * 40 - 20);
      const size = 10 + Math.random() * 20;
      
      ctx.save();
      ctx.globalCompositeOperation = 'destination-out';
      ctx.beginPath();
      ctx.arc(eraseX, eraseY, size/2, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
      
      // Occasionally comment on it
      if (Math.random() < 0.2) {
        updateAIMessage("Just making some improvements...", "neutral");
      }
    }
  }, 1000); // Erase every second while drawing
}

function stopErasingWhileDrawing() {
  if (eraseInterval) {
    clearInterval(eraseInterval);
    eraseInterval = null;
  }
}

document.getElementById('acceptChallenge').addEventListener('click', () => {
  popupChallenge.classList.remove('show');
  // Add bonus for accepting challenge
  userWillpower = Math.min(100, userWillpower + 15);
  updateStats();
  updateAIMessage("Alright! Let's see what you can do!", "happy");
});

document.getElementById('skipChallenge').addEventListener('click', () => {
  popupChallenge.classList.remove('show');
  // Reduced penalty for skipping
  userWillpower = Math.max(0, userWillpower - 5);
  updateStats();
  updateAIMessage("Maybe next time then.", "neutral");
  challengeActive = false;
  displayedTargetWord = originalWord;
  targetWordElem.textContent = displayedTargetWord;
});

document.getElementById('claimReward').addEventListener('click', () => {
  fakeReward.classList.remove('show');
  setTimeout(() => {
    updateAIMessage("HAHA! Just kidding! There's no reward here!", "crazy");
    aiAvatar.classList.add('shake');
    setTimeout(() => aiAvatar.classList.remove('shake'), 1000);
    userWillpower = Math.max(0, userWillpower - 15);
    updateStats();
  }, 500);
});

// Initialize game
function initGame() {
  displayedTargetWord = getRandomWord();
  secretTargetWord = displayedTargetWord;
  targetWordElem.textContent = displayedTargetWord;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  attempts = 0;
  aiSanity = 80;
  userWillpower = 100;
  currentColor = '#ffffff';
  drawing = false;
  drawingStarted = false;
  rewardShown = false;
  updateStats();
  updateAIMessage("Let's begin. Draw something for me.", "neutral");
  
  // Show first challenge after 3 attempts
  setTimeout(() => {
    showRandomChallenge();
  }, 3000);
}

// Drawing events
canvas.addEventListener('mousedown', (e) => {
  drawing = true;
  drawingStarted = true;
  [lastX, lastY] = [e.offsetX, e.offsetY];
  startErasingWhileDrawing();
  
  // Start annoying the user after a delay
  setTimeout(() => {
    if (drawing) {
      triggerRandomAnnoyance();
    }
  }, 2000); // Increased delay
});

canvas.addEventListener('mousemove', (e) => {
  if (!drawing) return;
  
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';

  ctx.beginPath();
  ctx.moveTo(lastX, lastY);
  ctx.lineTo(e.offsetX, e.offsetY);
  ctx.stroke();
  [lastX, lastY] = [e.offsetX, e.offsetY];
  
  // Reduced chance to trigger annoyances during drawing
  if (Math.random() < 0.05) {
    triggerRandomAnnoyance();
  }
  
  // Random line glitches - reduced frequency
  if (Math.random() < 0.01) {
    ctx.strokeStyle = ['#ff0000', '#00ff00', '#0000ff'][Math.floor(Math.random() * 3)];
    ctx.lineWidth = 1 + Math.random() * 5;
  } else {
    ctx.strokeStyle = currentColor;
    ctx.lineWidth = 3;
  }
});

canvas.addEventListener('mouseup', () => {
  drawing = false;
  stopErasingWhileDrawing();
});
canvas.addEventListener('mouseout', () => {
  drawing = false;
  stopErasingWhileDrawing();
});

// Submit button
document.getElementById('submitBtn').addEventListener('click', () => {
  if (challengeActive) {
    challengeActive = false;
    displayedTargetWord = originalWord;
    // Add challenge completion bonus
    userWillpower = Math.min(100, userWillpower + 20);
    aiSanity = Math.min(100, aiSanity + 10);
  }

  if (!drawingStarted) {
    updateAIMessage("You didn't draw anything.", "neutral");
    userWillpower -= 5;
    updateStats();
    return;
  }
  
  attempts++;
  attemptCountElem.textContent = attempts;
  aiSanity = Math.max(0, aiSanity - (5 + Math.random() * 5)); // Reduced sanity loss
  userWillpower = Math.max(0, userWillpower - (5 + Math.random() * 10)); // Reduced willpower loss
  updateStats();
  
  // Show fake reward after 2 attempts
  if (attempts === 2) {
    showFakeReward();
  }
  
  // Reduced chance the AI will change the target word
  if (Math.random() < 0.2) {
    secretTargetWord = getRandomWord(secretTargetWord);
  }
  
  // Determine if the drawing is "correct" (30% chance when wrong, 80% when right)
  const isCorrect = Math.random() < (displayedTargetWord === secretTargetWord ? 0.8 : 0.3);
  
  if (isCorrect) {
    updateAIMessage(
      correctResponses[Math.floor(Math.random() * correctResponses.length)],
      Math.random() < 0.5 ? "happy" : "neutral"
    );
    aiSanity = Math.min(100, aiSanity + 5);
    userWillpower = Math.min(100, userWillpower + 10);
    
    // Show new challenge after correct answer
    setTimeout(() => {
      showRandomChallenge();
    }, 2000);
  } else {
    const response = wrongResponses[Math.floor(Math.random() * wrongResponses.length)];
    updateAIMessage(
      response.includes('{word}') ? response.replace('{word}', secretTargetWord) : response,
      "neutral"
    );
    
    // Extra comment 30% of the time (reduced from 50%)
    if (Math.random() < 0.3) {
      setTimeout(() => {
        updateAIMessage(
          neutralResponses[Math.floor(Math.random() * neutralResponses.length)],
          "neutral"
        );
        userWillpower -= 3; // Reduced penalty
        updateStats();
      }, 1500);
    }
  }
  
  updateStats();
  
  // 30% chance of an additional delayed roast (reduced from 40%)
  if (Math.random() < 0.3) {
    setTimeout(() => {
      const newWord = getRandomWord(secretTargetWord);
      updateAIMessage(
        delayedRoasts[Math.floor(Math.random() * delayedRoasts.length)].replace('{word}', newWord),
        "neutral"
      );
      secretTargetWord = newWord;
      userWillpower -= 5; // Reduced penalty
      updateStats();
    }, 2000 + Math.random() * 3000);
  }
  
  // Check for game over states
  if (userWillpower <= 0) {
    setTimeout(() => {
      updateAIMessage("You've had enough. Game over.", "dead");
      document.getElementById('submitBtn').disabled = true;
    }, 3000);
  }
  
  if (aiSanity <= 0) {
    setTimeout(() => {
      updateAIMessage("I can't take anymore. You win?", "dead");
      document.getElementById('submitBtn').disabled = true;
    }, 3000);
  }
});

// Reset button
document.getElementById('resetBtn').addEventListener('click', () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawingStarted = false;
  userWillpower = Math.max(0, userWillpower - 5);
  updateStats();
  updateAIMessage("Starting fresh? Okay.", "neutral");
});

// New word button
document.getElementById('newWordBtn').addEventListener('click', () => {
  displayedTargetWord = getRandomWord(displayedTargetWord);
  secretTargetWord = displayedTargetWord;
  targetWordElem.textContent = displayedTargetWord;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawingStarted = false;
  userWillpower = Math.max(0, userWillpower - 5); // Reduced penalty
  updateStats();
  updateAIMessage("New word, let's try again.", "neutral");
});

// Rage quit button
document.getElementById('rageQuitBtn').addEventListener('click', () => {
  userWillpower = 0;
  updateStats();
  updateAIMessage("You gave up. That's too bad.", "dead");
  document.getElementById('submitBtn').disabled = true;
  
  // Dramatic effect
  document.body.style.backgroundColor = '#ff0000';
  setTimeout(() => {
    document.body.style.backgroundColor = '#222';
  }, 500);
});

// Initialize the game
initGame();

// Random background glitches - reduced frequency
setInterval(() => {
  if (Math.random() < 0.05 && aiSanity < 50) { // Reduced from 0.1
    document.body.style.filter = `hue-rotate(${Math.random() * 90 - 45}deg)`;
    setTimeout(() => {
      document.body.style.filter = '';
    }, 300);
  }
}, 5000);
</script>
</body>
</html>